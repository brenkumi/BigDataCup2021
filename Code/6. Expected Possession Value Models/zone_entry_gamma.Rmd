---
output: pdf_document
---

\centering
\Huge

**INLA SPDE Model - Controlled Entry Transition Model 1D**

\raggedright

\rule{\textwidth}{1.5pt}
\small

```{r setup, include = FALSE}
library(knitr) # For formatting the document
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

Summary: This file provides a template for building our spatiotemporal poisson regression model with INLA used in the transition matrix of our Markov Decision Process.

In particular, we are fitting the following transition models:

- Controlled Entry to Pass (to run, set to = c("Play", "Incomplete Play") on line 58)

- Controlled Entry to Shot (to run, set to = c("Shot", "Goal") on line 58)

- Controlled Entry to Turnover (to run, set to = c("Turnover") on line 58)


# Load data and packages

Load necessary packages

```{r load packages}
library(tidyverse) # For various data analysis functions

library(here) # To call or save code/data in certain folders

library(INLA) # To fit model with INLA

source(here::here("Code/2. Functions/Plotting-Functions.R")) # For ggField2 function
```

Load data set

```{r load data}
samples2 = readRDS(here::here("Data/all_samples_so_far2.Rda")) %>%
  filter(!is.na(event_id)) %>%
  filter(event == "Zone Entry")
```

# Data Preparation

Prepare our model matrix.

```{r data prep}
otters_data = read_csv(here::here("Data/otters_data_for_modelling.csv")) %>%
  filter(entry_strength == "ES") %>%
  mutate(time_since_entry.x = time_since_entry) %>%
  filter(event == "Zone Entry")

samples2 = samples2 %>%
  mutate(xG_0 = ifelse(Expected_Goals == 0, 1, 0)) %>%
  filter(xG_0 == 0) %>%
  bind_rows(otters_data) %>%
  mutate(is_near_boards = ifelse(same_direction_y <= 10 | same_direction_y >= 75, 1, 0)) %>%
  mutate(is_lead = ifelse(score_effect == "Lead", 1, 0)) %>%
  mutate(is_deficit = ifelse(score_effect == "Deficit", 1, 0)) %>%
  mutate(last_minute = ifelse(seconds > 1140, 1, 0)) %>%
  mutate(time_last_minute = ifelse(last_minute == 1, abs(seconds - 1200), 0))

model_coords2 = samples2$same_direction_y
```


# Building the INLA SPDE Mesh

Create a mesh

```{r mesh}
Mesh = inla.mesh.1d(0:85)
```

# Set Model Specifications

Set a prior and create a weight matrix and index for our model.

```{r spatial effect}
# Create an A matrix (sparse matrix representing each triangle)
model_A_matrix2 = inla.mesh.1d.A(Mesh, loc = model_coords2)

# Set the PC Matern prior
model_spde2 = inla.spde2.pcmatern(mesh = Mesh, prior.range = c(50, 0.6), prior.sigma = c(0.5, 0.5))

# Create w index
model_w_index2 = inla.spde.make.index("i", n.spde = model_spde2$n.spde)
```


```{r}
X2 = samples2 %>% 
  select(is_lead, is_deficit, time_last_minute, last_minute, is_near_boards)
```

Create a stack of all information to include in the model.

```{r stack}
# Initialize the stack
model_stack2 = inla.stack(
  
  # Add our response variable
  data = list(y = samples2$Expected_Goals), 
  
  # Add a list of the weights on the effects
  A = list(1, 1, model_A_matrix2),
  
  # Add the effects
  effects = list(
    
    # Intercept, repeat 1 n times
    Intercept = rep(1, nrow(samples2)),
    
    # Create a variable called is_near_boards to help us deal with discontinuity at the boards
    X = X2,
    
    # Our 1D spatial effect
    model_w_index2
    
  ))
```

Set the model formula

```{r formula}
model_formula2 = as.formula(paste0("y ~ -1 + Intercept ", 
                                  " + is_near_boards + is_lead + is_deficit + last_minute + time_last_minute",
                                  " + f(i, model = model_spde2)"))
```

# Model Results

Run our model

```{r model}
model2 = inla(model_formula2,
             
             family = "gamma",
             
             data = inla.stack.data(model_stack2),
             
             control.compute = list(dic = TRUE, config = TRUE),
             
             control.predictor = list(A = inla.stack.A(model_stack2), link = 1),
             
             num.threads = 8
)
```

Evaluate our model

```{r viz}
# Extract fitted values
fitval2 = model2$summary.fitted.values[1:nrow(samples2),] %>%
  mutate(x = samples2$same_direction_y)

# Plot entry means
entry_1d2 = ggplot(fitval2) +
  geom_point(aes(x = x, y = mean)) +
  geom_smooth(aes(x = x, y = mean), se = FALSE, colour = "green", size = 2)


# Print a model summary
summary(model2)
```



```{r}
ze_gamma_model = model2

saveRDS(ze_gamma_model, here::here("Models/Value/Zone_Entry_Gamma_Model.Rda"))
```


```{r}
fitted_values_gamma_ze = ze_gamma_model$summary.fitted.values[1:nrow(samples2),]

fitted_df_gamma_ze = cbind(samples2, fitted_values_gamma_ze) %>%
  filter(is.na(Expected_Goals)) %>%
  select(event_id, gamma = mean)



fitted_df_ze = merge(fitted_df_binom_ze, fitted_df_gamma_ze, by = "event_id", all.x = TRUE)

fitted_df_ze = fitted_df_ze %>%
  mutate(xV = (1-mean) * gamma)

with_pass_xG = read_csv(here::here("Data/with_pass_xG.csv")) %>% select(event_id, xG = mean)
no_pass_xG = read_csv(here::here("Data/no_pass_xG.csv")) %>% select(event_id, xG = mean)

xGs = rbind(with_pass_xG, no_pass_xG)


otters_with_values = fitted_df %>%
  bind_rows(fitted_df_ze) %>%
  arrange(event_id) %>%
  merge(xGs, by = "event_id", all.x = TRUE) %>%
  select(xV, everything()) %>%
  group_by(entry_id) %>%
  nest() %>%
  mutate(data = map(data, ~.x %>%
                      mutate(xG = ifelse(xG %in% NA, 0, xG))
                      mutate(next_xV = lead(xV)) %>%
                      mutate(PAV = xG + next_xV - xV) %>%
                      mutate(PAV = ifelse(next_event == "Exit", -xV, PAV))  %>%
                      mutate(PAV = ifelse(next_event == "Whistle", xG - xV, PAV)) %>%
                      mutate(PAV = ifelse(event == "Goal", xG - xV, PAV)) %>%
                      mutate(PAV2 = ifelse(event == "Shot" & next_event != "Whistle", xG - xV, PAV)) %>%
                      mutate(PAV3 = ifelse(event == "Shot" & next_event != "Whistle", (xG + (1-xG)*next_xV - xV), PAV)))) %>%
  unnest() %>% ungroup()

otters_with_values = otters_with_values %>%
  mutate(clean_event = case_when(
    event == "Goal" ~ "Shot",
    event == "Play" ~ "Pass",
    event == "Incomplete Play" ~ "Failed Pass",
    TRUE ~ event
  )) %>%
  select(xV, PAV, PAV2, PAV3, xG, clean_event, everything())

ggplot(otters_with_values) + 
  geom_histogram(aes(x = PAV), fill = "grey60") +
  theme_bw() +
  geom_vline(aes(xintercept = 0), colour = "red", linetype = "dashed") +
  facet_wrap(~event)

saveRDS(otters_with_values, "otters_PAV.Rda")
```


